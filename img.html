<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COPIA - IMG</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Press+Start+2P&family=Quicksand:wght@300..700&family=VT323&display=swap" rel="stylesheet">

<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow-x: hidden;
    }
     body {
            background: linear-gradient(45deg, #ffbf00, #FFFF00)
            min-height: 150vh;
            margin: 0;
            background-attachment: fixed;
            overflow-x: hidden;
        }

        .background-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            object-fit: cover;
            opacity: 30%;
            z-index: -1;
        }

    .video-container {
        position: absolute;
        max-width: 100vw;
        will-change: transform;
        transform-style: preserve-3d;
        filter: drop-shadow(.5rem .3rem 5px rgba(0, 0, 0, 0.5));
    }

    .fixed-element {
        position: fixed !important;
        transform: none !important;
    }
</style>
</head>
<body>
   <video class="background-video fixed-element" autoplay loop muted playsinline>
    <source src="https://res.cloudinary.com/djddsm416/video/upload/v1754604890/TV_STATIC_4K_60FPS_bjfnpa.mp4" type="video/mp4">
</video>

<div class="menu-hor-estilo">
       <a class="button-1" href="index.html" rel="history">HOME</a>     
       <a class="button-1" href="video.html" rel="history">VIDEO</a>
        <a class="button-1" href="img.html" rel="history">IMG</a>
        <a class="button-1" href="music.html" rel="history">MUSIC</a>
        <a class="button-1" href="others.html" rel="history">OTHERS</a>

            
    
        </div>
    

<div class="titulo-estilo fixed-element">
    IMG
</div>

<div class="habilidades-estilo fixed-element">
    <span class="button-2 heartbeat-1">PHOTO</span>
    <span class="button-2 heartbeat-2">AI</span>
    <span class="button-2 heartbeat-3">3D</span>
</div>
        </div>







    <!-- IMAGENES! -->



   






<script>
// --- Configuración ---
const CLOUD_NAME = "djddsm416"; // ¡Tu nombre de nube de Cloudinary!
const TAG_NAME = "img"; // La etiqueta que usaste en Cloudinary

// --- Lógica de la Galería ---
// --- Lógica de la Galería ---
async function fetchAndCreateImages() {
    const apiUrl = `https://res.cloudinary.com/${CLOUD_NAME}/image/list/${TAG_NAME}.json`;

    try {
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`Error: ${response.statusText}`);
        const data = await response.json();

        if (!data.resources || data.resources.length === 0) {
            console.warn(`No se encontraron imágenes con la etiqueta: ${TAG_NAME}`);
            return;
        }

        const container = document.querySelector('body');
        data.resources.forEach(img => {
            const div = document.createElement('div');
            div.className = 'video-container draggable';

            // --- LÓGICA DE TAMAÑO COMBINADA (RESPONSIVE + LÍMITES) ---

            // 1. LÍMITES MÁXIMOS: La caja de contención invisible.
            const MAX_ALLOWED_WIDTH = 600;
            const MAX_ALLOWED_HEIGHT = 550;

            // 2. TAMAÑO INICIAL RESPONSIVE: Para que se distribuyan bien.
            const PERCENT_OF_SCREEN = 0.45; // 45% del ancho de la pantalla
            const initialWidth = window.innerWidth * PERCENT_OF_SCREEN;
            
            // 3. APLICAMOS TODO AL 'div'
            // Le damos un tamaño inicial para que la función 'distributeImages' sepa cómo colocarlos.
            div.style.width = `${initialWidth}px`; 
            
            // Y le ponemos los topes para que no crezcan indefinidamente.
            div.style.maxWidth = `${MAX_ALLOWED_WIDTH}px`;
            div.style.maxHeight = `${MAX_ALLOWED_HEIGHT}px`;
            
            // --- FIN DE LA LÓGICA DE TAMAÑO ---

            div.style.cursor = 'grab';

            const imgElement = document.createElement('img');
            imgElement.src = `https://res.cloudinary.com/${CLOUD_NAME}/image/upload/v${img.version}/${img.public_id}.${img.format}`;
            imgElement.alt = img.public_id;

            // ESTO SE MANTIENE IGUAL Y ES LA CLAVE PARA NO DEFORMAR
            imgElement.style.width = 'auto'; 
            imgElement.style.height = 'auto'; 
            imgElement.setAttribute('draggable', 'false');

            div.appendChild(imgElement);
            container.appendChild(div);

            div.addEventListener('mousedown', handleDragStart);
        });
        
        // ¡IMPORTANTE! Llamamos a distributeImages DESPUÉS de que todas las imágenes se hayan creado.
        setTimeout(distributeImages, 100);

    } catch (error) {
        console.error("No se pudieron cargar las imágenes de la galería:", error);
    }
}

// ... (El resto de tu script de arrastre y demás sigue igual) ...


// --- Lógica de Arrastre (mejorada y centralizada) ---
let highestZIndex = 100;
let activeContainer = null;
let initialX, initialY;
let clickStartTime;

function handleDragStart(e) {
    e.preventDefault();
    clickStartTime = new Date().getTime();
    activeContainer = this; // 'this' es el div que recibió el click

    highestZIndex++;
    activeContainer.style.zIndex = highestZIndex;
    activeContainer.style.cursor = 'grabbing';
    
    initialX = e.clientX - activeContainer.offsetLeft;
    initialY = e.clientY - activeContainer.offsetTop;

    // Empezamos a escuchar los movimientos y el "soltar" en todo el documento
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd);
}

function handleDragging(e) {
    if (!activeContainer) return;
    e.preventDefault();
    const currentX = e.clientX - initialX;
    const currentY = e.clientY - initialY;
    activeContainer.style.left = `${currentX}px`;
    activeContainer.style.top = `${currentY}px`;
}

function handleDragEnd(e) {
    if (!activeContainer) return;

    const clickEndTime = new Date().getTime();
    const timeDiff = clickEndTime - clickStartTime;

    // Detectar si fue un click corto (para hacer zoom)
    if (timeDiff < 200) {
        const isScaled = activeContainer.style.transform.includes('scale(1.5)');
        activeContainer.style.transform = isScaled ? '' : 'scale(1.5)';
    }

    activeContainer.style.cursor = 'grab';
    
    // Dejamos de escuchar eventos, ¡muy importante!
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);

    // Guardar posición
    savePosition(activeContainer);
    
    activeContainer = null;
}


// --- Inicialización ---
document.addEventListener('DOMContentLoaded', fetchAndCreateImages);

</script>


<script>
function savePosition(container) {
    const positions = JSON.parse(localStorage.getItem('imagePositions') || '{}');
    positions[container.querySelector('img').alt] = {
        left: container.style.left,
        top: container.style.top,
        width: container.style.width
    };
    localStorage.setItem('imagePositions', JSON.stringify(positions));
}

function exportPositions() {
    const positions = JSON.parse(localStorage.getItem('imagePositions') || '{}');
    let code = '';
    
    for (const [name, pos] of Object.entries(positions)) {
        code += `<div class="video-container draggable" style="width: ${pos.width}; top: ${pos.top}; left: ${pos.left};">\n`;
    }
    
    console.log('Código HTML generado:');
    console.log(code);
}

document.addEventListener('mouseup', () => {
    if (!activeContainer) return;
    savePosition(activeContainer);
    // ...existing code...
});
</script>




<script>
function distributeImages() {
    const containers = document.querySelectorAll('.video-container:not(.fixed-element)');
    const gridSize = 4; // Número de elementos por fila
    const chaosLevel = 0.5;
    
    const minMargin = 50;
    const topMargin = 200;
    const rowSpacing = 500; // Espacio vertical entre filas
    const windowWidth = window.innerWidth - (minMargin * 2);
    
    const cellWidth = windowWidth / gridSize;
    
    containers.forEach((container, index) => {
        const col = index % gridSize; // Posición horizontal (0-4)
        const row = Math.floor(index / gridSize); // Fila (incrementa cada 5 elementos)
        
        const randomX = (Math.random() - 0.5) * cellWidth * chaosLevel;
        const randomY = (Math.random() - 0.5) * rowSpacing * chaosLevel;
        
        const baseX = minMargin + (col * cellWidth) + (cellWidth/2) - parseInt(container.style.width)/2;
        const baseY = topMargin + (row * rowSpacing); // Usar rowSpacing para separación vertical
        
        const finalX = baseX + randomX;
        const finalY = baseY + randomY;
        
        container.style.transition = 'transform 0.2s ease-out';
        container.style.left = `${Math.max(minMargin, Math.min(windowWidth, finalX))}px`;
        container.style.top = `${finalY}px`;
    });
}

// Run on page load
window.addEventListener('load', distributeImages);

// Run on window resize
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(distributeImages, 100);
});
</script>






</body>
</html>